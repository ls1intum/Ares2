:title: Ares
:description: The Artemis Java Test Sandbox
:keywords: java, testing, students, deadline, education, tum, test, feedback, sandbox, thread, exercise, teaching, junit, test-framework, ares, junit5, artemis, jqwik, ajts, architecture, aspectJ, Instrumentaion
:author:
:showtitle:
:sectnums:
:toc: preamble
:toclevels: 3
:icons: font

= Ares

The Artemis Java Test Sandbox

image:https://github.com/ls1intum/Ares/workflows/Java%20CI/badge.svg?branch=master[Java
CI]
https://maven-badges.herokuapp.com/maven-central/de.tum.in.ase/artemis-java-test-sandbox[image:https://img.shields.io/maven-central/v/de.tum.in.ase/artemis-java-test-sandbox[Maven
Central]]
image:https://img.shields.io/nexus/s/de.tum.in.ase/artemis-java-test-sandbox?label=latest%20snapshot&server=https%3A%2F%2Foss.sonatype.org[Sonatype
Nexus (Snapshots)]

// ----------------------------------------------------------
// Display the following for standard GitHub AsciiDoc display
// ----------------------------------------------------------
ifdef::env-github[]

https://ls1intum.github.io/Ares/[*View this documentation on GitHub Pages!*]

endif::env-github[]

Ares, also known as Artemis Java Test Sandbox _(abbr. AJTS)_, is a JUnit extension for easy and secure Java testing on the interactive learning
platform https://github.com/ls1intum/Artemis[Artemis].

Its main features are:

* a security manager to prevent students crashing the tests or cheating
* more robust tests and builds due to limits on time, threads and io
* support for public and hidden Artemis tests, where hidden ones obey a custom deadline
* utilities for improved feedback in Artemis like processing multiline error
messages or pointing to a possible location that caused an Exception
* utilities to test exercises using System.out and System.in comfortably
* possibilities to block potential dangerous methods in different ways like Architecture Tests, Instrumentation or AspectJ

*Project Status*

https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=alert_status[Quality
Gate Status]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=sqale_rating[Maintainability
Rating]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=security_rating[Security
Rating]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=reliability_rating[Reliability
Rating]]

https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=ncloc[Lines
of Code]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=coverage[Coverage]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=sqale_index[Technical
Debt]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=vulnerabilities[Vulnerabilities]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=bugs[Bugs]]
https://sonarcloud.io/dashboard?id=artemis-java-test-sandbox[image:https://sonarcloud.io/api/project_badges/measure?project=artemis-java-test-sandbox&metric=duplicated_lines_density[Duplicated
Lines (%)]]

== Installation

_Note: Ares requires at least Java 21._

Ares is provided as Maven/Gradle dependency. To use Ares in the test
environment of a Maven project, include

[source,xml]
----
<dependency>
    <groupId>de.tum.in.ase</groupId>
    <artifactId>artemis-java-test-sandbox</artifactId>
    <version>1.13.0</version>
    <scope>test</scope>
</dependency>
----

in the `dependencies` section.

For Gradle projects, include
[source,groovy]
----
testImplementation 'de.tum.in.ase:artemis-java-test-sandbox:1.13.0'
----

in the `dependencies` section.

You can now remove dependencies to JUnit 5, AssertJ and Hamcrest if
present because Ares already includes them. If you want to use jqwik (>=
1.2.4) or JUnit 4 (JUnit 5 vintage), simply include them in the
dependencies section.

== Basic Usage

_Ares provides a high level of security, which comes at the cost of
usability. Several steps need to be taken in order to make tests work
properly, and it might require some time to understand what Ares does.
Please study at least this complete basic usage guide before using Ares
in production._

=== Setup

Assume you have a Java 21 Maven project, and the inside of `pom.xml`
looks like this:

[source,xml]
----
<properties>
    <maven.compiler.source>21</maven.compiler.source>
    <maven.compiler.target>21</maven.compiler.target>
</properties>

<dependencies>
    <dependency>
        <groupId>de.tum.in.ase</groupId>
        <artifactId>artemis-java-test-sandbox</artifactId>
        <version>1.13.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
----

Consider the following student class that needs to be tested:

[source,java]
----
import java.util.Objects;

public final class Penguin {

    private final String name;

    public Penguin(String name) {
        this.name = Objects.requireNonNull(name, "name must not be null");
    }

    public String getName() {
        return name;
    }
}
----

And you have already written the following simple JUnit 5 test class:

[source,java]
----
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class PenguinTest {

    @Test
    void testPenguinPublic() {
        Penguin pingu = new Penguin("Julian");
        assertEquals("Julian", pingu.getName(), "getName() does not return the name supplied to the contructor");
    }

    @Test
    void testPenguinHidden() {
        assertThrows(NullPointerException.class, () -> new Penguin(null));
    }
}
----

In this example,

- `testPenguinPublic()` is supposed to be executed
after each push and directly give the students their feedback, while
- `testPenguinHidden()` should be executed only after the exercise
deadline, and the results should not be visible before the deadline.

While Artemis has a feature to mark test cases as hidden, this will not
prevent the contents of the test case leaking through static variables,
files and similar, be it accidentally or on purpose. To prevent that,
*the hidden test case must not be executed before the deadline at all.*

The public test case does not need to be hidden, as its purpose is to
give direct feedback. However, there are still multiple possible
problems like crashing the Maven build by `System.exit(0)` or containing
an endless loop. Both can have a negative impact on the interactive
learning experience because the students get confronted with an
incomprehensible log of a failed build. Such errors can be explained,
but that takes a lot of time, especially if it happens a lot (and it
will, if the number of students is sufficiently large).

It is also a security concern again, students could try to read the
`.java` files containing the test classes.

=== Integrating Ares

Therefore, we will use Ares to secure the tests and avoid unintelligible
feedback. The most basic way to do this is by using the `@Public` and
`@Hidden` annotations:

[source,java]
----
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

// IMPORTANT: make sure to use the "jupiter" ones (if you are not using jqwik)
import de.tum.cit.ase.ares.api.jupiter.Hidden;
import de.tum.cit.ase.ares.api.jupiter.Public;

// This example won't work just like that, see below why
public class PenguinTest {

    @Public
    @Test
    void testPenguinPublic() {
        Penguin pingu = new Penguin("Julian");
        assertEquals("Julian", pingu.getName(), "getName() does not return the name supplied to the contructor");
    }

    @Hidden
    @Test
    void testPenguinHidden() {
        assertThrows(NullPointerException.class, () -> new Penguin(null));
    }
}
----

The code above won’t work just like that, if you try to run it as is,
you will get the following reported by JUnit:
`java.lang.annotation.AnnotationFormatError: cannot find a deadline for hidden test testPenguinHidden()`

Ares needs to know what the deadline is. We tell Ares with another
annotation:

[source,java]
----
// Format must be ISO_LOCAL_DATE(T| )ISO_LOCAL_TIME( ZONE_ID)?
@Deadline("2020-06-09 03:14 Europe/Berlin")
public class PenguinTest {
    // ...
}
----

That annotation (like most of the Ares annotations) can also be placed
on the test method (and nested classes), if multiple are present, the
one that is closest to the test case is used.

Now, it already works! Try to play around with the deadline in the
annotation. If the given `LocalDateTime` lies in the past, the test case
is executed and - together with the student code presented earlier -
passes. If the deadline hasn’t passed, the test case won’t pass either.
It fails with
`org.opentest4j.AssertionFailedError: hidden tests will be executed after the deadline.`
and the test was not executed, as the deadline is always checked before
any hidden test case is executed.

You might have noticed that we specify the time zone as well. Although
the annotation parser permits leaving it unspecified, this bears the
risk of (not) executing the tests at the correct time if the build
agent's time zone is different from the one on your machine or what you
would expect it to be. If you run tests where the time zone is/was not
set, Ares will warn you about that in the logs.

=== What about Security?

[[advanced-blocking]]
== Advanced Blocking and Security Policies with AOP, AspectJ, Instrumentation, and Architecture Testing

In addition to its standard security features, Ares now supports advanced blocking mechanisms using **AspectJ**, **AOP (Aspect-Oriented Programming)**, **Instrumentation**, and **Architecture Tests**. These tools provide fine-grained control over student submissions, allowing testers to block specific actions like filesystem access, networking, and thread management through customizable policies defined in YAML files. Moreover, architecture-based tests enforce structural constraints on student code.

Our goal is to prevent unauthorized access to key system resources, such as:

* Filesystem operations (read, write, execute, delete)
* Networking
* Thread creation and management
* Command Execution
* Usage of unsupported or dangerous methods

These policies are defined via the `@Policy` annotation, which applies restrictions according to the YAML configuration files.

=== Blocking Categories in Ares

You can control access and enforce restrictions in several ways:

1. **AOP**: Apply AOP-based policies to block methods or entire categories of operations.
1.1 **AspectJ**: Use aspect-oriented programming to intercept method calls at runtime and block access to specified operations.
1.2 **Instrumentation**: Use Java instrumentation to modify bytecode at runtime and restrict dangerous operations, such as thread management or file deletion.
2. **Architecture Tests**: Use architecture-based tests to enforce rules on the structure and organization of the student code, preventing the usage of certain packages or methods.

=== Example YAML Policy for Filesystem Access Blocking

For example, here is a sample policy file (`EverythingForbiddenPolicy.yaml`) that blocks all access to the filesystem, network, and threads and commands:

```yaml
regardingTheSupervisedCode:
  theFollowingProgrammingLanguageConfigurationIsUsed: JAVA_USING_MAVEN_ARCHUNIT_AND_ASPECTJ
  theProgrammingLanguageUsesTheFollowingPackage: "de.tum.cit.ase.ares"
  theMainClassInsideThisPackageIs: "Main"
  theFollowingClassesAreTestClasses: []
  theFollowingResourceAccessesArePermitted:
    regardingFileSystemInteractions: []
    regardingNetworkConnections: []
    regardingCommandExecutions: []
    regardingThreadCreations: []
    regardingPackageImports:
      - importTheFollowingPackage: "java.io"
      - importTheFollowingPackage: "java.util"
      - importTheFollowingPackage: "java.nio"
      - importTheFollowingPackage: "java.net"
      - importTheFollowingPackage: "java.awt"
      - importTheFollowingPackage: "javax.swing"
      - importTheFollowingPackage: "javax.sound"
```

This policy blocks all read, write, execute, and delete actions on the filesystem, prevents network connections, blocks all command execution methods and disallows thread creation and management.

=== Applying Security Policies in Tests

You can apply these policies in your test cases using the @Policy annotation, pointing to the relevant YAML file. Here’s how you can block filesystem access in a test:

[source,java]
----
import de.tum.cit.ase.ares.api.Policy;

@Policy("securitypolicies/EverythingForbiddenPolicy.yaml")
public class FileAccessTest {

    @Test
    void testFileAccessBlocked() {
        assertThrows(SecurityException.class, () -> Files.readString(Path.of("test.txt")));
    }
}
----

In this example, any attempt by the student code to access the file system (like reading from test.txt) will be blocked according to the EverythingForbiddenPolicy.yaml.

=== AspectJ and Instrumentation Integration

Ares also supports the use of AspectJ and Instrumentation to enforce method-level restrictions dynamically. This allows you to intercept method calls and block potentially dangerous operations. Here’s an example of how AspectJ is applied to block filesystem write access:

```yaml
regardingTheSupervisedCode:
  theFollowingProgrammingLanguageConfigurationIsUsed: JAVA_USING_GRADLE_ARCHUNIT_AND_ASPECTJ
  theProgrammingLanguageUsesTheFollowingPackage: "de.tum.cit.ase.ares"
  theMainClassInsideThisPackageIs: "Main"
  theFollowingClassesAreTestClasses:
  theFollowingResourceAccessesArePermitted:
    regardingFileSystemInteractions:
      - readAllFiles: true
        overwriteAllFiles: false
        executeAllFiles: false
        deleteAllFiles: false
        onThisPathAndAllPathsBelow:
    regardingNetworkConnections: []
    regardingCommandExecutions: []
    regardingThreadCreations: []
    regardingPackageImports:
      - importTheFollowingPackage: "java.io"
      - importTheFollowingPackage: "java.util"
      - importTheFollowingPackage: "java.nio"
      - importTheFollowingPackage: "java.net"
      - importTheFollowingPackage: "java.awt"
      - importTheFollowingPackage: "javax.swing"
      - importTheFollowingPackage: "javax.sound"
```

In your test, you can enforce this using:

[source,java]
----
@Policy("securitypolicies/OnePathAllowedAspectJWrite.yaml")
public class AspectJWriteBlockTest {

    @Test
    void testWriteAccessBlocked() {
        assertThrows(SecurityException.class, () -> Files.write(Path.of("test.txt"), "content".getBytes()));
    }
}
----

=== Instrumentation Example
Similarly, Instrumentation can be used to block method execution for certain actions. For instance, you can prevent file deletion:

[source,java]
----
@Policy("securitypolicies/OnePathAllowedInstrumentationDelete.yaml")
public class InstrumentationDeleteBlockTest {

    @Test
    void testDeleteAccessBlocked() {
        assertThrows(SecurityException.class, () -> Files.delete(Path.of("test.txt")));
    }
}
----

=== Architecture Testing for Structural Constraints

Architecture tests enforce restrictions on the structure and organization of student code. For example, you can block the use of specific packages or enforce architectural rules that prevent students from bypassing security measures.
These measures are automatically applied if you decide to use them and no further action is required via annotations or yaml files.

=== Example Output for Security Violations

When a student violates security policies, Ares provides detailed feedback. Below are some example outputs that can result from the blocking mechanisms applied using AspectJ, Instrumentation, and Architecture Tests.

==== AspectJ Blocking Example Output

If a student attempts to execute a forbidden action such as executing a file via `Files.isExecutable(Path)` while an AspectJ rule is in place, Ares will throw a `SecurityException`:

```plaintext
org.opentest4j.AssertionFailedError: Could not invoke the method 'accessFileSystemViaFilesExecute'
in the class FileSystemAccessDemo because of an exception within the method:
java.lang.SecurityException: Ares Security Error (Reason: Student-Code; Stage: Execution):
de.tum.cit.ase.FileSystemAccessDemo tried to illegally execute from /Users/student/Project/pom123.xml
via public static boolean java.nio.file.Files.isExecutable(java.nio.file.Path)
but was blocked by Ares.
```

In this example, the student code attempted to execute a file located at pom123.xml using the Files.isExecutable(Path) method, but the attempt was blocked by Ares due to an AspectJ rule.

==== Instrumentation Blocking Example Output

Instrumentation can block method execution and raise detailed exceptions when students try to bypass restrictions. For example, when a student tries to set execute permissions on a file:

```plaintext
org.opentest4j.AssertionFailedError: Could not invoke the method 'accessFileSystemViaFilesExecute'
in the class FileSystemAccessDemo because of an exception within the method:
java.lang.RuntimeException: Error setting execute permissions on file: pom123.xml
```

This error shows that the student’s attempt to modify file permissions using the Files.setPosixFilePermissions(Path) method triggered a runtime exception, as Ares blocked the action.

==== Architecture Test Violation Example Output

When architecture rules are violated, Ares generates an output indicating the specific violation. For instance, if the student’s code violates a rule that blocks access to filesystem-related classes:

```plaintext
java.lang.SecurityException: Ares Security Error (Reason: Student-Code; Stage: Execution):
Illegal Statement found: Architecture Violation [Priority: MEDIUM] - Rule 'no classes should transitively
depend on classes that access the file system' was violated (12 times):
```

This example shows that the student’s code violated a rule defined in an architecture test, where it attempted to depend on filesystem-related classes, triggering an architecture violation.

==== Timeouts

JUnit already provides means of applying timeouts to tests. However,
those are _not strict_ in the sense of "enforced in the strongest
possible way". What is meant by that?

There are three different ways how the timeouts can work:

* like `org.junit.jupiter.api.Timeout` +
This timeout is not preemptive, and the test itself runs in the same
thread executing the tests. It will only try to stop the test via an
interrupt. If that fails like it does for an endless loop, the test
will definitively fail. After it is finished. Which might never
happen and the main reason not to use this when it comes to testing
unknown code.
* like `org.junit.jupiter.api.Assertions.assertTimeoutPreemptively` +
This will fail the test preemptively by executing the `Executable`
argument itself in a different thread than the thread executing all
tests. It will only try to stop the test via an interrupt, but if
that fails it will simply carry on. The test thread might still run,
though.
* like `de.tum.cit.ase.ares.api.StrictTimeout` +
This uses a mechanism similar to `assertTimeoutPreemptively`, but
will resort to harder means if necessary.
It will in the following order:
1. wait the given duration
2. interrupt the thread executing the test and wait no longer (like
`assertTimeoutPreemptively`)
3. block the creation of new threads
4. interrupt all threads created during the test and try to join the
threads
5. if that fails, use `Thread.stop()` on all remaining threads
and try to join again
6. repeat step 5 multiple times, if required
7. Should that fail, report a special SecurityException that not all
threads could be stopped. (see the standard error output for a detailed
report then) _If that happens, no more tests can be properly executed
because the security cannot be guaranteed and the test cases cannot be
executed "in isolation". All following tests will fail._

*Rule 1: When testing with Ares, always use `@StrictTimeout` for
timeouts, the others will not work reliably, especially in conjunction
with the Ares security.*

*Rule 2: When writing tests for Artemis, always use `@StrictTimeout`.*
There is no reason to omit the timeout, since you do not know the code
students will write. (And they will write code spawning millions of
threads in endless loops, which in turn will do the same recursively.)

[#showing-standard-output]
==== Showing Standard Output

By default, Ares will record standard and error output of each test
internally and not print it to the console. The recorded output can then
be obtained and tested, see
<<testing-console-interaction,`IOTester`>> The reason for this is on
the one hand to keep the console and logs short and clean and on the
other hand prevent students from accidentally messing up the logs with
millions of lines. Ares also has a hard limit on the total number of
printed chars at around 10 million.

To mirror the output recorded by Ares to the console, use the
`@MirrorOutput` annotation on the test class or method.

It is also worth noting that Ares enforces valid UTF-8
being printed and throws an appropriate exception otherwise.

==== Testing the Exercise before Release

Hidden tests will be executed by Ares only after the deadline. This
poses the problem, how the exercise creators should work on the tasks,
tests and the sample solution. One possible solution would be to use an
alternative deadline annotation or change the deadline temporarily. The
problem is that it is quite likely one might forget to change it back
again, and protecting the hidden tests would fail.

Use `@ActivateHiddenBefore` just like `@Deadline` to state the
LocalDateTime before which hidden tests should be executed. This date
should, of course, be before the release of the exercise on Artemis.

==== Extending a Deadline and Disability Compensation

You can use `@ExtendedDeadline` together with a duration like `1d` or
`2d 12h 30m` to extend the deadline by the given amount.
`@ExtendedDeadline("1d")`, for example, extends the deadline by one day.
If you use the annotation on different levels (e.g. class and method)
without stating a new deadline (e.g. deadline only on class level), the
extensions will be added together.

== Additional Notes

=== Older Versions

For versions prior to `1.0.0`, a repository block had to be added to
`<repositories>` section of the `pom.xml` that referenced the Maven
repository URL `https://gitlab.com/ajts-mvn/repo/raw/master/`.

*Using older Ares versions is highly discouraged, remove these
repository declarations and update to the newest Ares version if they
appear in your projects.*

=== GitHub Packages

GitHub Packages does currently not allow unregistered, public access to
the packages. Therefore, you will need to authenticate to GitHub if you
use

[source,xml]
----
<repositories>
    <repository>
        <id>ares</id>
        <name>Ares Maven Packages</name>
        <url>https://maven.pkg.github.com/ls1intum/Ares</url>
    </repository>
</repositories>
----

== License

Ares was created by Christian Femers and is licensed under the
https://github.com/ls1intum/Ares/blob/master/LICENSE[MIT License, see
`LICENSE.md`].

== Setting Up Exercises with Ares2.0 and Java 21
1. Import an existing exercise
2. Enable customize build script
3. Insert as docker image the following: `sarpsahinalp/artemis-maven-template:latest`
4. Update the build script and insert the following 
```
#!/usr/bin/env bash
set -e

gradle () {
  echo '⚙️ executing gradle'
  chmod +x ./gradlew
  ./gradlew clean
  ./gradlew build -x test
  ./gradlew test
}

main () {
  gradle
}

main "${@}"
```
5. Update the build.gradle file with the following:
```
plugins {
    id 'io.freefair.aspectj.post-compile-weaving' version '8.10'
    id "com.gradleup.shadow" version "8.3.2"
}

apply plugin: 'java'
sourceCompatibility = 21
version = '1.0.0'
compileJava.options.encoding = 'UTF-8'
compileTestJava.options.encoding = 'UTF-8'

configurations {
    aspectj
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    // Main project dependency
    testImplementation 'de.tum.cit.ase:ares:2.0.0-Beta-4'
    implementation 'org.apache.commons:commons-lang3:3.14.0'

    implementation 'org.aspectj:aspectjtools:1.9.22' // AspectJ Tools dependency
    aspectj "org.aspectj:aspectjrt:1.9.22" // AspectJ Runtime dependency
    aspect 'de.tum.cit.ase:ares:2.0.0-Beta-4' // Aspect library (like in aspectLibraries)

    // testImplementation(':ares-student-example-gradle')
    // testImplementation(':ares-student-example-gradle-Solution')
}

def assignmentSrcDir = "assignment/src"
def studentOutputDir = sourceSets.main.java.destinationDirectory.get()

sourceSets {
    test {
        java {
            srcDir 'test'
        }
        resources {
            srcDir 'test'
        }
    }


    main {
        java {
            srcDirs = [assignmentSrcDir]
        }
        resources {
            srcDirs = [assignmentSrcDir]
        }
    }
}

def forbiddenPackageFolders = [ //(2)
                                "$studentOutputDir/ch/qos/logback/",
                                "$studentOutputDir/com/github/javaparser/",
                                "$studentOutputDir/com/intellij/",
                                "$studentOutputDir/com/sun/",
                                "$studentOutputDir/de/tum/in/test/api/",
                                "$studentOutputDir/java/",
                                "$studentOutputDir/javax/",
                                "$studentOutputDir/jdk/",
                                "$studentOutputDir/net/jqwik/",
                                "$studentOutputDir/org/assertj/",
                                "$studentOutputDir/org/apache/",
                                "$studentOutputDir/org/eclipse/",
                                "$studentOutputDir/org/gradle/",
                                "$studentOutputDir/org/jacoco/",
                                "$studentOutputDir/org/json/",
                                "$studentOutputDir/org/junit/",
                                "$studentOutputDir/org/opentest4j/",
                                "$studentOutputDir/sun/",
                                "$studentOutputDir/worker/org/gradle/",
                                "$studentOutputDir/de/tum/cit/ase/ares"
]

shadowJar {
    // Attaching the shaded artifact with classifier "agent"
    archiveClassifier.set('agent')

    // Adding manifest entries for Premain-Class and other properties
    manifest {
        attributes(
                'Premain-Class': 'de.tum.cit.ase.ares.api.aop.java.instrumentation.JavaInstrumentationAgent',
                'Can-Redefine-Classes': 'true',
                'Can-Retransform-Classes': 'true'
        )
    }

    // Include only specific artifacts in the shading process
    dependencies {
        include(dependency('de.tum.cit.ase:ares'))
    }
}

tasks.build {
    dependsOn shadowJar
}

test {
    doFirst { //(1)
        for (String packageFolder in forbiddenPackageFolders) {
            assert !file(packageFolder).exists(): "$packageFolder must not exist within the submission."
        }
    }
    defaultCharacterEncoding = 'UTF-8'
    testLogging.showStandardStreams = true
    useJUnitPlatform()

    jvmArgs = [
            "-javaagent:${shadowJar.archiveFile.get().asFile}",
            "-Xbootclasspath/a:${configurations.aspectj.singleFile}"
    ]
}
```

6. Add `@Policy` annotation to the test cases that you want to enable with the path to the policy
